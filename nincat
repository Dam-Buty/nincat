#!/usr/bin/env sh
#
# DESCRIPTION:
#   This a simple script that loads an ASCII art centered in your terminal.
#
#   It will look for art that can be loaded in the terminal size.
#   So I do recommend you to have multiple arts.
#
#   If you want nincat to print faster, then just use a POSIX-compliant shell,
#   I do recommend dash (which as 4x faster than bash).
#   
# TODO:
#   ? GETOPS (fast implementation) (high doubt I will add this)
#   ? Support HEX colours (true colours) (maybe?)
#   + File with list of names to ignore certain arts! faster than O(n)
#
# NOTE:
#   Keep the current syntax for developing!
#
# MAINTAINER(s):
#   BeyondMagic : 2021- : koetemagie@gmail.com
#
# GPL3 Â© 2021 : github.com/BeyondMagic/nincat

# NOTE 1:
# Path of this script, it will use a fast and simple way to go to the path and
# get from there using 'pwd -P'. If you want to set an absolute path, I'd 
# recommend you to put in somewhere that you can update to get new arts!
# Obviosuly if you call it with an enviroment variable, as `path_script`, it 
# will override.
path_script="$(cd -- "$(dirname "$0")" >/dev/null 2>&1 && pwd -P)"

# NOTE 2:
# Columns of terminal, it may be worth noticing that MAYBE $COLUMNS and $lines
# can be a better alternative because if the program is faster than the tiling
# window manager, it will get wrong columns and lines. Since $COLUMNS is slower
# to get. Let's see if in the future something happens and we resolve it by
# adding it.
columns=$(tput cols)

# NOTE 3:
# Print all the arts files that it finds with the `find` command, it will
# print the name after the root directory. This may be useful to the day
# that we add a `.ignorearts` file to keep
# updating without overriding the arst that we changed or updated.
# Verify if the file exists and then put its path if it does.
#find "$path_script/ascii_arts/" -type f -size +0 | \
#  sed "s*$path_script/ascii_arts/**" | \
#  awk '{print $(NF-2), $(NF-1), $NF}'; exit 0

# NOTE 4:
# If there's an argument (which is the filename secondpath), then choose it 
# instead of a random. Remember that the secondpath counts from the root of 
# the foler `ascii_arts`, so if, for example, there's an art called `bird 4 7`
# in the `ascii_arts/lolcat/`, the correct way to call it should be
# `nincat "lolcat/bird 4 7"`.
# If you aren't sure the path, then just enable the commands of the comment
# above.
[ "$1" ] || {

  # NOTE 5:
  # Select a random art that fits in the terminal size.
  # 1. 'find' will get all ASCII art paths in this directory that are not
  #    empty.
  # 2. 'awk' will get only the files that can fit in this terminal based only
  #    the name;
  # 3. 'shuf' will randomize the list
  # 4. 'head' will get the first file of the list.
  selected="$(find "$path_script/ascii_arts/" -type f -size +0 | \
    awk "(\$(NF-1) <= $(($(tput lines) - 1))) && (\$NF <= $columns)" | \
    shuf | head -n1)"


# See note 4
} && [ -f "$path_script/ascii_arts/$1" ] && \
  selected="$path_script/ascii_arts/$1"

# NOTE 6:
# This block of code will only execute if an ASCII art is found, note that it 
# you can added a command to exit with an error, like it didn't find something
# with '|| exit 1' at the end of the block or after this condition in the next
# line.
[ "$selected" ] && {

  # NOTE 7:
  # Print the name of the file, you can add $NF to print certain fields, if you
  # just want the name, remove the $(NF-2), $(NF-1) for that.
  # If you want the full path, remove the sed call in the following 2 lines:
  #printf "$selected\n" | sed "s*$path_script/ascii_arts/**" | \
  #  awk '{print $(NF-2), $(NF-1), $NF}'

  # NOTE 8:
  # This will print the art to a variable.
  # Importante execution order:
  # 1. 'printf' will get columns of the filename with grep (faster than awk).
  # 2. Math operation will find the number to add characters to a line and
  #    center it.
  # 3. 'printf' will print the spaces to center the string with loop.
  # 4. 'sed' will append as prefix to all lines of the file and delete the 1st
  #     line that is supposed to be your name/username, etc.
  art="$(sed -e "s/^/$(printf %$(( \
    (columns - $(printf "$selected" | grep -oE '[^ ]+$')) / 2 ))s)/" \
    -e '1d' "$selected")"

  # NOTE 9:
  # If it finds 'lolcat' on the path, then print with the 'lolcat' random
  # If not, then it will printf normally with a reset colour and background
  # after the art.
  # Change the 'lolcat' optiions if you want something different as some
  # lolcat(s) have less/more options.
  [ $(printf "$selected" | grep -c 'lolcat') = 0 ] && \
    printf "$art\n\033[0m" || \
    printf "$art\n" | lolcat -r

}
